from group_action import __version__, __num_of_cores__
from group_action.library import *
from functools import lru_cache

def convert_int(hypergraph, n):
	return convert_bits_to_int(hypergraph_to_bool_func(hypergraph, n))

def power_set(X):
	"""
	Generate power set of X
	"""
	# assert X is a list
	if not (type(X) is list):
		raise Exception("Input is not a list")

	# Chain together all combinations of different lengths
	return list(itertools.chain.from_iterable(itertools.combinations(X, r) for r in range(len(X) + 1)))

def action1(g, x):
	"""
	First action
	G, X, g.x
	g is a list representing a 2-cycle or g is a 0-cycle
	ex: g=[1,2] means g(1) = 2, g(2) = 1, g(other) = other
	"""
	result = x
	if x in g:
		result = g[0]		
		if x == g[0]:
			result = g[1]
	return result

@lru_cache(None)
def action2(g, A):
	"""
	Second action
	G, P(X), g.A = {g.x, x in A}
	"""
	result = [action1(g, x) for x in A]
	return result

def action3(g, B):
	"""
	Third action
	G, P(P(X)), g.B = {g.A, A in B}
	"""
	result = [action2(g, A) for A in B]
	return result

def hypergraph_to_bool_func(hypergraph, n):
	"""
	Convert a hypergraph to a Boolean function (truth table).
	
	Parameters:
	- hypergraph: Set of hyperedges. Each hyperedge is a subset of {0, 1, ..., n-1}.
	- n: Number of variables (nodes in the hypergraph)
	
	Returns:
	- bool_func: List of Boolean outputs for each input combination of n variables (size 2^n)
	"""
	bool_func = [0] * (2 ** n)
	
	# Iterate over all possible input combinations (binary numbers)
	for hyperedge in hypergraph:
		i=0
		for pos in hyperedge:
			i += 1 << pos
		bool_func[i] = 1

	return bool_func

def task(transposition, chunk, n):
	"""
	Atomic task
	"""
	partial_edges = []
	for function in chunk:
		new_function = action3(transposition, function)
		partial_edges += [[convert_int(function,n), convert_int(new_function,n)]]
	return partial_edges

def main():
	"""
	Compute the orbits generated by the action of Sn on B^B^n.
	"""
	print_header()

	# Create the parser
	parser = argparse.ArgumentParser(description='Computation of the orbits generated by the action of the symmetric group Sn via its transpositions on n-input Boolean functions generated by actions on power sets.')

	# Add the arguments
	# Add the --version flag to the parser
	parser.add_argument('--version', action='version', version=f'%(prog)s {__version__}')
	parser.add_argument('--n', type=int, default=2, help='Number of inputs')
	parser.add_argument('--c', type=int, default=__num_of_cores__, help='Number of cores')
	parser.add_argument('--v', action='store_true', help='Output every element of each orbit')
	parser.add_argument('--j', action='store_true', help='Output data.json file')

	# Parse the arguments
	args = parser.parse_args()

	# Print arguments summary
	print_arguments_summary(args, parser, __version__)

	"""
	Initialize Default value
	"""

	# number of inputs
	n=args.n

	# number of cores
	num_cores=args.c

	# verbose output
	verbose = args.v

	# json data output
	json_data_output = args.j

	# Computing symmetric group
	permutations = generate_transpositions(n)
	permutations += [()]

	# Computing functions
	X = list(range(n))
	PX = power_set(X)
	PPX = power_set(PX)
	functions = PPX

	# Total number of functions
	size = 2**(2**n)

	# Define the chunk size
	chunk_size = 2**(n+2)

	# Define the number of jobs
	num_jobs = len(permutations) * size // chunk_size

	# Split the list into chunks
	chunks = chunk_list(functions, chunk_size)

	with tqdm_joblib(tqdm(desc="Brut force orbit computing", total=num_jobs)) as progress_bar:
		results = Parallel(n_jobs=num_cores)(delayed(task)(permutation, chunk, n) for permutation in permutations for chunk in chunks)

	# Generating vertices
	vertices = [k for k in range(size)]

	# Merging list of lists
	edges = list(itertools.chain.from_iterable(results))

	# Computing orbits
	orbits = find_connected_components(vertices, edges)

	size = len(orbits)

	# data list
	data = []

	# Printing orbits
	print(f"Set of {n}-input Boolean functions orbits")
	for i, orbit in enumerate(orbits):
		orbit_size=len(orbit)
		signatures = [orbit[k] for k in range(len(orbit))]
		representative = signatures[0]
		if verbose:
			print(f"index: {i}, size: {orbit_size}, signatures: {signatures}")
		else:
			print(f"index: {i}, representative: {representative}")

		if json_data_output:
			if verbose:
				data += [{"index": i, "size": orbit_size, "signatures": signatures}]
			else:
				data += [{"index": i, "representative": representative}]

	if json_data_output:
		# Specify the filename
		filename = 'data.json'

		# Write the dictionary to a JSON file
		with open(filename, 'w') as file:
			json.dump(data, file, indent=4)  # indent=4 for pretty printing

	print_footer()

if __name__ == '__main__':
	main()
